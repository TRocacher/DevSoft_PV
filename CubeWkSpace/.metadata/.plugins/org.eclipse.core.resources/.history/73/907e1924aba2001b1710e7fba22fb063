/*
 * MyAnalog.c
 *
 *  Created on: 15 Avril. 2021
 *      Author: trocache
 *
 *  CIBLE : stm32L476RG (Nucléo board)
 *  IDE : Cube IDE vers 1.5.1
 *  CONTEXTE : gestion soft système PV
 *  DEPENDENCES :
 *
 *
 */


#include "Menu.h"

/******************************************************************************
*  PRIVATE Variables
*
******************************************************************************/

// Variable MenuItem
enum {First, Middle, Last};
typedef struct Menu_Node Menu_Node;
struct Menu_Node {
	Menu_Node *  NextNode;
	Menu_Node *  PreviousNode;
	Menu_Node *  UpNode;
	Menu_Node *  DownNode;
	char * Title;
	char MenuPosition;
	char * ItemToPrint;
	void (*NodeExecFct)(void);
};







enum {Entry, Do, Exit};
#define NbMenu 3

char Space[]="                    ";

struct MenuStatusTypedef {
	 int  ActualMenu;
  	 void (*MenuPtrFct[NbMenu])(void);
	 int ActualMenuState; // {Entry, Do, Exit}
	 float InputValue;
	 char NewInputValueFlag;
	 float ValueToPrint[10];
	 char NewValueToPrint[10];
} MenuStatus;


struct MenuScreenTypedef {
	// Menu Input Menu
	char NbItemsToPrint;
	char InputValueDigits[10]; // pour input menu, c'est les digits de l'input Value (non utilisé 			    // directement pour l'affichage)
	char LineColToHighLight[2];// contient la coordonnée du caractère actif
	// Menu Navigation et Information
	char * PtrLine[10]; // ce sont 10 pointeurs vers 10 strings maximum
	char FirstItemToPrint; // utile pour le scrolling, on affiche la première ligne puis 3 suivantes en 		                 //partant de  FirstLineToPrint
	char ActiveItem;         // l'item à mettre en surbrillance, -1 pour retour en arrière
} MenuScreenData;


// pour tester
#define Up 24
#define Down 25
#define Right 26
#define Left 27
char Touch;



/******************************************************************************
*  PRIVATE declaration

******************************************************************************/
enum {M_Demarrage, M_DemarrageMPPT, M_DemarrageBattChg, M_Param};
void MenuFct_Demarrage(void);
void MenuFct_DemarrageMPPT(void);
void MenuFct_DemarrageBattChg(void);
void MenuFct_Param(void);



/******************************************************************************
*  PUBLIC FUNCTION

******************************************************************************/

void Init_Menu(void)
{
	/*************************************
	 * init attribut MenuStatus
	 *************************************/
	MenuStatus.ActualMenu=M_Demarrage;
	MenuStatus.ActualMenuState=Entry;
	MenuStatus.InputValue=12.5;
	MenuStatus.NewInputValueFlag=0;
	// chargement du tableau de pointeur de fonction
	MenuStatus.MenuPtrFct[M_Demarrage]=MenuFct_Demarrage;
	MenuStatus.MenuPtrFct[M_DemarrageMPPT]=MenuFct_DemarrageMPPT;
	MenuStatus.MenuPtrFct[M_DemarrageBattChg]=MenuFct_DemarrageBattChg;
	MenuStatus.MenuPtrFct[M_Param]=MenuFct_Param;
	// valeurs à imprimer à 0.0
	for (int i=0 ;i<=9 ;i++)
	{
		MenuStatus.ValueToPrint[i]=0.0;
		MenuStatus.NewValueToPrint[i]=0;
	}


}





/******************************************************************************
*  PRIVATE functions

******************************************************************************/

void MenuPrintNavInfoScreen(void)
{
	switch(Touch)
			{
			case Up:
				if 	(MenuScreenData.ActiveItem!=1)
				{
					// besoin de scroller vers le haut ?
					if (MenuScreenData.ActiveItem==MenuScreenData.FirstItemToPrint) MenuScreenData.FirstItemToPrint--;
					MenuScreenData.ActiveItem--;
				}
				break;
			case Down:
				if 	(MenuScreenData.ActiveItem!=MenuScreenData.NbItemsToPrint)
				{
					// besoin de scroller vers le bas ?
					if ((MenuScreenData.ActiveItem-MenuScreenData.FirstItemToPrint)==3)	MenuScreenData.FirstItemToPrint++;
					MenuScreenData.ActiveItem++;
				}
				break;
			case Right:
				MenuStatus.ActualMenuState=Exit;
				break;
			case Left:
				MenuStatus.ActualMenuState=Exit;
				MenuScreenData.ActiveItem=255;
				break;
			}

	// TO DO
	// - afficher les 4 lignes : la première et les 3 autres à partir de l'item actif
	// mettre en surbrillance la ligne indiquée


}


/*==========================================================================================
 *
 * 		Chargement des maillons MenuNodes
 *
 *
 ==========================================================================================*/

Menu_Node Item_Menu1, Item_Menu_2, Item_Menu_3, Item_Menu_4, Item_Menu_5, Item_Null;
Void NullFct(void) {}

void Menu_Node_Init(void)
{

	/*      **********************
	 * 		*Menu principal      *
	 * 		*1> Nenu 1			 * <-
	 * 		*2> Menu 2			 *
	 * 		*3> Menu 3			 *
	 * 		*4> Menu 4			 *
	 * 		*5> Menu 5			 *
	 * 		**********************
	 */
	Item_Menu1.DownNode=&Item_Menu_2;
	Item_Menu1.NextNode=& Item_Null;
	Item_Menu1.UpNode=&Item_Menu1;  // lui même
	Item_Menu1.PreviousNode=&Item_Menu1;  // lui même

	Item_Menu1.MenuPosition=First;
	Item_Menu1.Title="Menu principal";
	Item_Menu1.NextNode="1> Nenu 1";
	Item_Menu1.NodeExecFct=NullFct;

	/*      **********************
	 * 		*Menu 1			     *
	 * 		*1> Nenu 1_1		 *
	 * 		*2> Menu 1_2		 *
	 * 		*3> Menu 1_3		 *
	 * 		**********************
	 */

	/*      **********************
	 * 		*Menu 2			     *
	 * 		*1> Nenu 2_1		 *
	 * 		*2> Menu 2_2		 *
	 * 		**********************
	 */


	/*      **********************
	 * 		*Menu 2_1			 *
	 * 		*1> Nenu 2_1_1		 *
	 * 		*2> Menu 2_1_2		 *
	 * 		*3> Menu 2_1_3		 *
	 * 		*3> Menu 2_1_4		 *
	 * 		**********************
	 */

	/*      **********************
	 * 		*Menu 4			     *
	 * 		*1> Nenu 4_1		 *
	 * 		*2> Menu 4_2		 *
	 * 		**********************
	 */

	/*      **********************
	 * 		*Menu 5			     *
	 * 		*1> Nenu 5_1		 *
	 * 		*2> Menu 5_2		 *
	 * 		*3> Menu 5_3		 *
	 * 		**********************
	 */
}






void MenuProgress(void)
{
	MenuStatus.MenuPtrFct[MenuStatus.ActualMenu]();
}



/**
  * @brief
  */
